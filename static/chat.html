<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Realtime Chat</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¬</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.1/socket.io.min.js"></script>
    <!-- For rendering AI's markdown responses -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
  </head>
  <body class="bg-gray-100 min-h-screen">
    <div class="h-screen flex bg-white">
      <!-- Sidebar (hidden on small screens) -->
      <aside id="sidebar" class="hidden md:flex w-80 border-r p-4 bg-gray-50 flex-col">
        <div class="flex items-center justify-between mb-4">
          <h3 class="font-semibold">Chats</h3>
          <button id="btn_refresh_chats_desktop" class="px-2 py-1 bg-gray-200 rounded text-sm">Refresh</button>
        </div>
        
        <div class="my-3">
          <input id="room_input" placeholder="room id or user id" class="w-full border rounded px-3 py-2" />
          <div class="flex gap-2 mt-2">
            <button id="btn_join_room" class="bg-blue-600 text-white px-3 py-1 rounded">Join Room</button>
            <button id="btn_join_dm" class="bg-gray-600 text-white px-3 py-1 rounded">Open DM</button>
          </div>
        </div>

        <div class="my-3">
          <div class="flex items-center justify-between">
            <h4 class="font-medium">All Users</h4>
            <button id="toggle_users_list" class="text-xs px-2 py-1 bg-gray-200 rounded">Hide</button>
          </div>
          <div id="all_users_list" class="mt-2 max-h-40 overflow-y-auto border rounded p-1">
            <!-- all users will be listed here -->
          </div>
        </div>

        <h4 class="font-medium mt-4">Active Room</h4>
        <p id="active_room" class="text-sm text-gray-600">(none)</p>

        <div id="chat_list_container" class="flex-grow overflow-y-auto">
          <!-- Chat list will be rendered here -->
        </div>

        <!-- Logout Button at the bottom -->
        <div class="mt-auto">
          <button id="btn_logout" class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">Logout</button>
        </div>
      </aside>

      <!-- Main area -->
      <div class="flex-1 flex flex-col">
        <!-- top bar for mobile -->
        <div class="md:hidden flex items-center justify-between px-3 py-2 border-b bg-white">
          <div class="flex items-center gap-3">
            <button id="btn_toggle_sidebar" class="px-2 py-1 bg-gray-200 rounded">â˜°</button>
            <div class="text-sm font-medium" id="active_room_mobile">(none)</div>
          </div>
          <div>
            <button id="btn_refresh_chats" class="px-2 py-1 bg-gray-200 rounded">Refresh</button>
          </div>
        </div>

        <div class="flex-1 p-4 flex flex-col overflow-hidden">
          <div class="flex-1 mb-4 overflow-auto" id="messages_container" style="min-height:0;">
            <!-- messages will be appended here -->
          </div>

          <div class="flex gap-2">
            <input id="msg_input" placeholder="Type a message" class="flex-1 border rounded px-3 py-2" />
            <button id="btn_send" class="bg-green-600 text-white px-4 py-2 rounded" disabled>Send</button>
          </div>
        </div>
      </div>
    </div>

    <script>
    // --- Configuration ---
    // Since the frontend is served by the backend, we can use relative paths.
    const API_BASE_URL = ''

    // We now rely on server-set cookies for auth (access_token HttpOnly cookie).
    // Socket.IO will send cookies automatically on same-origin connections and the server
    // will read the access_token cookie.
    // For same-origin, withCredentials is not strictly needed but doesn't hurt.
    const socket = io(API_BASE_URL, { withCredentials: true });
    const markdownConverter = new showdown.Converter();

    const activeRoomEl = document.getElementById('active_room')
    let activeRoom = null
    let chats = {groups: [], conversations: []}

    // load chats for the user and render sidebar list
    async function loadChats(){
      const res = await fetch(`/chat/chats`, {credentials: 'include'})
      if(res.status === 401){
        // token missing/expired -> send user to login
        window.location = '/'
        return
      }
      const data = await res.json()
      chats = data
      renderChatList()
    }

    function renderChatList(){
      const container = document.getElementById('chat_list_container');
      container.innerHTML = ''; // Clear previous list

      // Create a new container for the list
      const chatListContainer = document.createElement('div');
      chatListContainer.className = 'mt-4';

      // Add AI Assistant as the first item
      const aiHeader = document.createElement('h5');
      aiHeader.className = 'font-semibold';
      aiHeader.innerText = 'Assistant';
      chatListContainer.appendChild(aiHeader);
      const aiItem = document.createElement('div');
      aiItem.className = 'flex items-center justify-between group';
      const openAiBtn = document.createElement('button');
      openAiBtn.className = 'flex-grow text-left py-1 px-2 rounded hover:bg-indigo-100 font-medium text-indigo-700';
      openAiBtn.innerText = 'ðŸ¤– AI Assistant';
      openAiBtn.onclick = () => openChat('ai_assistant');
      const clearAiBtn = createClearAiHistoryButton(clearAiHistory);
      aiItem.appendChild(openAiBtn);
      aiItem.appendChild(clearAiBtn);
      chatListContainer.appendChild(aiItem);

      // conversations (DMs)
      const convHeader = document.createElement('h5');
      convHeader.className = 'font-semibold mt-2';
      convHeader.innerText = 'Direct messages';
      chatListContainer.appendChild(convHeader);

      (chats.conversations || []).forEach(c => {
        const item = document.createElement('div');
        item.className = 'flex items-center justify-between group';
        const openBtn = document.createElement('button');
        openBtn.className = 'flex-grow text-left py-1 px-2 rounded hover:bg-gray-200';
        const currentUserId = (document.cookie || '').split(';').map(c => c.trim()).find(c => c.startsWith('user_id='))?.split('=')[1];
        
        const isSelfDm = c.participant_ids && c.participant_ids.every(id => id === currentUserId);
        let display = c.participant_display_name || 'DM'; // Default to the name from backend

        // Override for self-DM case
        if (isSelfDm) { 
          display = 'You (Saved Messages)';
        }

        let preview = '';
        if (c.last_message && c.last_message.content) {
          preview = ' â€” ' + (c.last_message.content.length > 30 ? c.last_message.content.slice(0, 27) + '...' : c.last_message.content);
        }
        const label = `${display}${preview}`;
        openBtn.innerText = label;
        openBtn.onclick = () => openChat(c.room_id);
        const deleteBtn = createDeleteButton(() => deleteChat(c._id, 'conversations'));
        item.appendChild(openBtn);
        item.appendChild(deleteBtn);
        chatListContainer.appendChild(item);
      });

      // groups
      const grpHeader = document.createElement('h5');
      grpHeader.className = 'font-semibold mt-4';
      grpHeader.innerText = 'Groups';
      chatListContainer.appendChild(grpHeader);

      (chats.groups || []).forEach(g => {
        const item = document.createElement('div');
        item.className = 'flex items-center justify-between group';
        const openBtn = document.createElement('button');
        openBtn.className = 'flex-grow text-left py-1 px-2 rounded hover:bg-gray-200';
        let preview = '';
        if (g.last_message && g.last_message.content) {
          preview = ' â€” ' + (g.last_message.content.length > 30 ? g.last_message.content.slice(0, 27) + '...' : g.last_message.content);
        }
        openBtn.innerText = (g.name || g._id) + preview;
        openBtn.onclick = () => openChat('group:' + g._id);
        const deleteBtn = createDeleteButton(() => deleteChat(g._id, 'groups'));
        item.appendChild(openBtn);
        item.appendChild(deleteBtn);
        chatListContainer.appendChild(item);
      });

      // Append the constructed list to the container
      container.appendChild(chatListContainer);
    }

    function createDeleteButton(onClick) {
      const btn = document.createElement('button');
      btn.innerHTML = '&#x1F5D1;'; // Trash can icon
      btn.className = 'px-2 py-1 text-xs rounded hover:bg-red-200 opacity-0 group-hover:opacity-100 transition-opacity';
      btn.title = 'Delete Chat';
      btn.onclick = onClick;
      return btn;
    }

    function createClearAiHistoryButton(onClick) {
      const btn = document.createElement('button');
      btn.innerHTML = '&#x1F5D1;'; // Trash can icon
      btn.className = 'px-2 py-1 text-xs rounded hover:bg-red-200 opacity-0 group-hover:opacity-100 transition-opacity';
      btn.title = 'Clear AI Chat History';
      btn.onclick = onClick;
      return btn;
    }

    async function deleteChat(id, type) {
      if (!confirm('Are you sure you want to delete this chat forever?')) return;
      try {
        const res = await fetch(`/chat/${type}/${id}`, { method: 'DELETE', credentials: 'include' });
        if (!res.ok) throw new Error(`Failed to delete: ${res.statusText}`);
        console.log(`${type} with id ${id} deleted.`);
        await loadChats(); // Refresh the chat list
      } catch (error) {
        console.error('Error deleting chat:', error);
      }
    }

    async function clearAiHistory() {
      if (!confirm('Are you sure you want to clear your AI chat history? This cannot be undone.')) return;
      try {
        const res = await fetch(`/chat/ai/history`, { method: 'DELETE', credentials: 'include' });
        if (!res.ok) throw new Error(`Failed to clear history: ${res.statusText}`);
        console.log('AI chat history cleared.');
        // If the AI chat is currently active, refresh it to show it's empty
        if (activeRoom === 'ai_assistant') {
          openChat('ai_assistant');
        }
      } catch (error) {
        console.error('Error clearing AI history:', error);
      }
    }

    async function openChat(room){
      // Special handling for AI chat
      if (room === 'ai_assistant') {
        activeRoom = room;
        activeRoomEl.innerText = 'AI Assistant';
        document.getElementById('active_room_mobile').innerText = 'AI Assistant';
        const res = await fetch('/chat/ai/history', { credentials: 'include' });
        const history = await res.json();
        renderAiHistory(history);
        return;
      }

      activeRoom = room;
      let chat = findChatByRoomId(room);
      let displayName = room; // Default to room ID as a fallback

      // If chat details aren't in the cache, or it's a group, fetch fresh data.
      // This is useful for the "Join Room" feature.
      if (!chat && room.startsWith('group:')) {
        const groupId = room.split(':')[1];
        try {
          const res = await fetch(`/chat/groups/${groupId}`, { credentials: 'include' });
          if (res.ok) {
            chat = await res.json();
            // Manually add room_id for consistency
            if(chat) chat.room_id = room;
          }
        } catch (e) { console.error("Failed to fetch group details", e); }
      }

      // Determine the display name for the active chat
      if (chat && chat.type === 'dm') {
        displayName = chat.participant_display_name || 'DM';
      } else if (chat) { // It's a group
        displayName = chat.name || 'Group';
      }

      activeRoomEl.innerText = displayName;
      // update mobile top label
      document.getElementById('active_room_mobile').innerText = displayName;

      // join via socket
      socket.emit('join_room', {room});

      // Render history from the chat object we found or fetched
      renderHistory(chat, room);
    }

    function findChatByRoomId(roomId) {
      if (roomId.startsWith('group:')) {
        const groupId = roomId.split(':')[1];
        return chats.groups.find(g => g._id === groupId);
      }
      if (roomId.startsWith('dm:')) {
        return chats.conversations.find(c => c.room_id === roomId);
      }
      return null;
    }

    function renderHistory(chat, room) {
      const msgs = chat ? chat.messages || [] : [];
      console.log(`Rendering history for room ${room || 'unknown'}:`, msgs); // Debug log
      const container = document.getElementById('messages_container');
      container.innerHTML = '';
      const currentUser = (document.cookie || '')
        .split(';')
        .map(c => c.trim())
        .find(c => c.startsWith('user_id='));
      const currentUserId = currentUser ? currentUser.split('=')[1] : null;
      (msgs || []).forEach(m => {
        const el = document.createElement('div');
        el.className = 'mb-2 flex';
        const isMe = m.sender_id && m.sender_id === currentUserId;
        const senderLabel = m.sender_username || (isMe ? 'You' : m.sender_id || 'unknown');
        const bubbleClass = isMe ? 'ml-auto bg-blue-100 text-right' : 'mr-auto bg-gray-200 text-left';
        el.innerHTML = `<div class="p-2 rounded ${bubbleClass} max-w-[80%]">
          <div class="text-sm text-gray-800">${escapeHtml(m.content || '')}</div>
          <div class="text-xs text-gray-500 mt-1">${senderLabel} â€¢ ${formatTimestamp(m.created_at)}</div>
        </div>`;
        container.appendChild(el);
      });
      container.scrollTop = container.scrollHeight;
      document.getElementById('btn_send').disabled = false;
    }

    function renderAiHistory(chat) {
      const msgs = chat ? chat.messages || [] : [];
      const container = document.getElementById('messages_container');
      container.innerHTML = '';
      const currentUserId = (document.cookie || '').split(';').map(c=>c.trim()).find(c=>c.startsWith('user_id='))?.split('=')[1];

      if (!msgs || msgs.length === 0) {
        const el = document.createElement('div');
        el.className = 'mb-2 flex';
        el.innerHTML = `<div class="p-2 rounded bg-indigo-100 text-left max-w-[80%]">
          <div class="text-sm text-gray-800">Hello! How can I help you today?</div>
          <div class="text-xs text-gray-500 mt-1">AI Assistant</div>
        </div>`;
        container.appendChild(el);
        return;
      }

      (msgs || []).forEach(m => {
        const el = document.createElement('div');
        el.className = 'mb-2 flex';
        const isMe = m.role === 'user';
        const senderLabel = isMe ? 'You' : 'AI Assistant';
        const bubbleClass = isMe ? 'ml-auto bg-blue-100 text-right' : 'mr-auto bg-indigo-100 text-left';
        
        // Render markdown for AI messages
        const contentHtml = m.role === 'assistant' ? markdownConverter.makeHtml(m.content || '') : escapeHtml(m.content || '');

        el.innerHTML = `<div class="p-2 rounded ${bubbleClass} max-w-[80%]">
          <div class="text-sm text-gray-800">${contentHtml}</div>
          <div class="text-xs text-gray-500 mt-1">${senderLabel}</div>
        </div>`;
        container.appendChild(el);
      });
      container.scrollTop = container.scrollHeight;
      document.getElementById('btn_send').disabled = false;
    }

    socket.on('connect', ()=>{
      console.log('connected', socket.id)
    })

    socket.on('connect_error', (err) => {
      console.error('Socket.IO connection error:', err); // Debug log
    });

    // small helper to avoid injecting raw HTML
    function escapeHtml(unsafe) {
      return String(unsafe)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;")
    }

    function formatTimestamp(iso){
      if (!iso) return '';
      try {
        return new Date(iso).toLocaleString();
      } catch(e) {
        return iso;
      }
    }

  socket.on('message', (payload)=>{
      const m = payload.message || {}
      // only render message if it's for the currently active room
      if (m.chat_id !== activeRoom) return;
      const container = document.getElementById('messages_container')      
      const el = document.createElement('div')
      el.className = 'mb-2 flex';
      const currentUser = (document.cookie || '').split(';').map(c=>c.trim()).find(c=>c.startsWith('user_id='))?.split('=')[1]
      const isMe = (m.sender_id && m.sender_id === currentUser)
      const senderLabel = m.sender_username || ((m.sender_id && m.sender_id === currentUser) ? 'You' : (m.sender_id || 'unknown'))
      const bubbleClass = isMe ? 'ml-auto bg-blue-100 text-right' : 'mr-auto bg-gray-200 text-left'
      el.innerHTML = `<div class="p-2 rounded ${bubbleClass} max-w-[80%]">
        <div class="text-sm text-gray-800">${escapeHtml(m.content || '')}</div>
        <div class="text-xs text-gray-500 mt-1">${senderLabel} â€¢ ${formatTimestamp(m.created_at)}</div>
      </div>`
      container.appendChild(el);
      // keep scroll at bottom for new messages
      container.scrollTop = container.scrollHeight
    })

    socket.on('system', (d)=>{
      const container = document.getElementById('messages_container')
      const el = document.createElement('div')
      el.className = 'mb-2 text-xs text-gray-500'
      el.innerText = d.message
      container.prepend(el)
    })

    document.getElementById('btn_join_room').onclick = async ()=>{
      const groupName = document.getElementById('room_input').value.trim();
      if(!groupName) {
        console.error('Group name is empty');
        return;
      }
      console.log(`Attempting to join or create group: ${groupName}`);
      try {
        // Call the new endpoint to join or create the group
        const res = await fetch(`/chat/groups/join-or-create`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({ name: groupName }),
          credentials: 'include'
        });
        if (!res.ok) throw new Error(`Server responded with ${res.status}`);
        const group = await res.json();
        const room = `group:${group._id}`;
        await loadChats(); // Refresh sidebar to show the new/joined group
        openChat(room);
      } catch (error) {
        console.error('Failed to join room:', error);
      }
    };

    document.getElementById('btn_join_dm').onclick = async ()=>{
      const other = document.getElementById('room_input').value.trim();
      if(!other) {
        console.error('User ID is empty');
        return;
      }
      console.log(`Attempting to open DM with: ${other}`); // Debug log
      try {
        const res = await fetch(`/chat/dm/`+encodeURIComponent(other), {method:'POST', credentials:'include'});
        if(res.status === 401){
          window.location = '/';
          return;
        }
        if (!res.ok) {
          throw new Error(`Failed to create DM: ${res.statusText}`);
        }
        const conv = await res.json();
        console.log('DM conversation data:', conv); // Debug log
        const room = conv.room_id || `dm:${other}`;
        await loadChats(); // Refresh sidebar to include the new DM
        openChat(room); // Now open the chat, which will find it in the updated `chats` object
      } catch (error) {
        console.error('Failed to open DM:', error);
      }
    };

    document.getElementById('btn_send').onclick = () => {
      let content = document.getElementById('msg_input').value.trim();
      if (!activeRoom) {
        console.error('No active room selected');
        return;
      }
      if (!content) {
        console.error('Message content is empty');
        return;
      }

      // Handle AI chat separately
      if (activeRoom === 'ai_assistant') {
        sendToAi(content);
      } else {
        // Regular chat logic
        console.log(`Sending message to room ${activeRoom}: ${content}`); // Debug log
        try {
          socket.emit('message', {
            room: activeRoom,
            content
          });
          console.log('Message emitted successfully'); // Debug log
          document.getElementById('msg_input').value = '';
        } catch (error) {
          console.error('Failed to send message:', error);
        }
      }
    };

    // --- AI Chat Logic (Integrated) ---
    async function sendToAi(content) {
      document.getElementById('msg_input').value = '';
      document.getElementById('btn_send').disabled = true;

      // Add user message to UI immediately
      addMessageToContainer({ role: 'user', content: content });

      // Add a temporary AI bubble
      const aiMessageBubble = addMessageToContainer({ role: 'assistant', content: '...' }, true);
      let fullResponse = '';

      try {
          const response = await fetch('/chat/ai', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ content }),
              credentials: 'include'
          });

          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              fullResponse += decoder.decode(value, { stream: true });
              // Update the content of the bubble's inner div
              aiMessageBubble.querySelector('.text-sm').innerHTML = markdownConverter.makeHtml(fullResponse + '...');
              document.getElementById('messages_container').scrollTop = document.getElementById('messages_container').scrollHeight;
          }
          aiMessageBubble.querySelector('.text-sm').innerHTML = markdownConverter.makeHtml(fullResponse);
      } catch (error) {
          aiMessageBubble.querySelector('.text-sm').innerHTML = 'Sorry, an error occurred.';
          console.error('AI chat error:', error);
      } finally {
          document.getElementById('btn_send').disabled = false;
          document.getElementById('msg_input').focus();
      }
    };

    // send on enter key
    document.getElementById('msg_input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // prevent new line
        document.getElementById('btn_send').click();
      }
    });

    // --- Logout ---
    document.getElementById('btn_logout').onclick = async () => {
      const res = await fetch(`/auth/logout`, { method: 'POST', credentials: 'include' });
      if (res.ok) {
        // Redirect to login page on successful logout
        window.location.href = '/';
      }
    };

    // --- User List Toggle ---
    document.getElementById('toggle_users_list').onclick = () => {
      const list = document.getElementById('all_users_list');
      const btn = document.getElementById('toggle_users_list');
      if (list.style.display === 'none') {
        list.style.display = 'block';
        btn.innerText = 'Hide';
      } else {
        list.style.display = 'none';
        btn.innerText = 'Show';
      }
    };

    // --- All Users List ---
    async function loadAllUsers() {
      const res = await fetch(`/chat/users`, { credentials: 'include' });
      if (!res.ok) return;
      const users = await res.json();
      renderAllUsers(users);
    }

    function renderAllUsers(users) {
      const container = document.getElementById('all_users_list');
      container.innerHTML = '';
      if (!users || users.length === 0) {
        container.innerHTML = '<p class="text-xs text-gray-500 p-2">No other users found.</p>';
        return;
      }
      const currentUserId = (document.cookie || '').split(';').map(c=>c.trim()).find(c=>c.startsWith('user_id='))?.split('=')[1]
      users.forEach(user => {
        const btn = document.createElement('button');
        btn.className = 'w-full text-left py-1 px-2 rounded hover:bg-gray-200 text-sm';
        const isCurrentUser = user._id === currentUserId;
        btn.innerText = isCurrentUser ? `${user.username} (You)` : user.username;
        btn.onclick = () => {
          // Populate the DM input and click the button to start a chat
          document.getElementById('room_input').value = user._id;
          document.getElementById('btn_join_dm').click();
        };
        container.appendChild(btn);
      });
    }

    // initial load
    loadChats().catch(()=>{})
    loadAllUsers().catch(()=>{})
    </script>
    
    <script>
    // Helper to add a message to the main container (used by AI chat)
    function addMessageToContainer(message, returnElement = false) {
        const container = document.getElementById('messages_container');
        const el = document.createElement('div');
        el.className = 'mb-2 flex';
        const isMe = message.role === 'user';
        const senderLabel = isMe ? 'You' : 'AI Assistant';
        const bubbleClass = isMe ? 'ml-auto bg-blue-100 text-right' : 'mr-auto bg-indigo-100 text-left';
        const contentHtml = message.role === 'assistant' ? markdownConverter.makeHtml(message.content || '') : escapeHtml(message.content || '');

        el.innerHTML = `<div class="p-2 rounded ${bubbleClass} max-w-[80%]">
          <div class="text-sm text-gray-800">${contentHtml}</div>
          <div class="text-xs text-gray-500 mt-1">${senderLabel}</div>
        </div>`;
        container.appendChild(el);
        container.scrollTop = container.scrollHeight;

        if (returnElement) return el;
    }
    </script>
  </body>
 </html>
